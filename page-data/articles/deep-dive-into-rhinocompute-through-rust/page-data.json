{"componentChunkName":"component---src-templates-article-post-js","path":"/articles/deep-dive-into-rhinocompute-through-rust","result":{"data":{"markdownRemark":{"html":"<h2>はじめに</h2>\n<p>最近流行りの言語として Rust があり、触ってみたいと思っている方も多いのではないでしょうか。\nただ、建築系ソフトをみるとその多くが Python や C# で SDK が提供されており、仕事で使わない Rust のような言語に触れることはほぼありません。</p>\n<p>ならば Rust で建築系のソフトのなにかを操作できるようになれば、Rust を触れる機会が生まれるはずです。\nということで、本記事では Rhinoceros と HTTP 通信することで Rhinoceros の機能を使うことができる RhinoCompute を Rust で使う方法について紹介します。</p>\n<p>本記事でははじめに Rust を触る前にどのように実装するべきか確認するため、RhinoCompute と通信することへの理解を深めます。\nその後、その内容に基づいて Rust で実行環境を作成します。</p>\n<p>技術的には Rust でも Rhino のデータを取得し rhino3dm 相当の操作が可能です。\nしかしそのための実装は時間がかかるため、Grasshopper データを Post して RhinoCompute を使いその結果を取得することを目標とします。</p>\n<h3>必要な環境</h3>\n<ul>\n<li>Rhinoceros 7 以降</li>\n<li>Grasshopper の Hops コンポーネント v0.11 以降</li>\n<li>Rust(作成段階で rustc 1.58.1 を使っています)</li>\n</ul>\n<h2>RhinoCompute との通信内容について</h2>\n<h2>Rust について</h2>\n<p>Rust の特徴を<a href=\"https://www.rust-lang.org/ja\">公式サイト</a>より引用します。</p>\n<blockquote>\n<p>なぜ Rust か？</p>\n<p><strong>パフォーマンス</strong><br>\nRust は非常に高速でメモリ効率が高くランタイムやガベージコレクタがないため、パフォーマンス重視のサービスを実装できますし、組込み機器上で実行したり他の言語との調和も簡単にできます。</p>\n<p><strong>信頼性</strong><br>\nRust の豊かな型システムと所有権モデルによりメモリ安全性とスレッド安全性が保証されます。さらに様々な種類のバグをコンパイル時に排除することが可能です。</p>\n<p><strong>生産性</strong><br>\nRust には優れたドキュメント、有用なエラーメッセージを備えた使いやすいコンパイラ、および統合されたパッケージマネージャとビルドツール、多数のエディタに対応するスマートな自動補完と型検査機能、自動フォーマッタといった一流のツール群が数多く揃っています。</p>\n</blockquote>\n<p>こういった特徴があり C/C++ に代わる言語として注目されています。\nインストールも同様に <a href=\"https://www.rust-lang.org/ja/tools/install\">公式サイトのインストール</a> よりできます。</p>\n<p>開発に VSCode を使う場合は Rust の公式が出している <a href=\"https://marketplace.visualstudio.com/items?itemName=rust-lang.rust\">Rust</a> という Extension がありますが、それを使うより <a href=\"https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer\">rust-analyzer</a> を使うことをおススメします。</p>\n<p>VSCode の Settings で Rust-analyzer›Check On Save: Command の設定がデフォルトでは check になっていますが、clippy にすると保存するごとに linter が走るのでコードの確認をしやすくなります。\n修正の提案もしてくれるのでとても便利です。</p>\n<p>基本的な事項については公式のドキュメントがとても充実しているので実際に自分でコードを書いていきたい方は一読すると理解が深まります。<br>\n<a href=\"https://doc.rust-jp.rs/book-ja/\">The Rust Programming Language 日本語版</a></p>\n<h2>Rust を使った RhinoCompute 実行の実装</h2>\n<p>ここで作成するものは GitHub にあげていますので必要に応じて参照しながらすすめてください。</p>\n<ul>\n<li><a href=\"https://github.com/hrntsm/RustHopper\">RustHopper</a></li>\n</ul>\n<h3>Json との IO 用の構造体の作成</h3>\n<p>はじめに cargo を使って新しいパッケージを作成します。\n名前を \"rusthopper\" とする場合は以下です。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">cargo new rusthopper</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>通信部を作成する前に Input/Output で Json を簡単にやり取りするための構造体を作成します。\nJson へのシリアライズ/デシリアライズをサポートする crate は Rust では serde が主に使われています。\nここでも同様に使用するので、Cargo.toml に以下を追加します。</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-toml line-numbers\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">dependencies</span><span class=\"token punctuation\">]</span>\n<span class=\"token key property\">serde</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1.0.136\"</span>\n<span class=\"token key property\">serde_derive</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1.0.136\"</span>\n<span class=\"token key property\">serde_json</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1.0.78\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>src ディレクトリに io.rs ファイルを作成し、ここに Json を I/O するための構造体を作成します。</p>\n<p>この構造体は RhinoCompute のリポジトリにある <a href=\"https://github.com/mcneel/compute.rhino3d/blob/master/src/compute.geometry/IO/Schema.cs\">Schema.cs</a> を基に作成します。\n上であげたようにここのクラスを使って RhinoCompute 側は処理しているので、この Schema に倣うことでスムーズにデータのやり取りができ量になります。</p>\n<p>ただ、これを 0 から実装していくとが面倒なので、自動実装を使うと楽です。\n例えばこちらの <a href=\"https://transform.tools/json-to-rust-serde\">transform.tools</a> を使うと Json から Rust の構造体を作成できるので、それを下敷きに足りない部分を手で修正してくことをおススメします。</p>\n<p>Hops から出力された Json がここでも役に立ちます。\n例として Hops のポストした IO への Json を変換すると以下のようになります。</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"absolutetolerance\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"angletolerance\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"algo\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"7VgJUBNZGk4gQ.....\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"pointer\"</span><span class=\"token operator\">:</span> <span class=\"token null keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"cachesolve\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"recursionlevel\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"values\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"warnings\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"errors\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">use serde_derive::Deserialize;\nuse serde_derive::Serialize;\nuse serde_json::Value;\n\n#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct Root {\n    pub absolutetolerance: f64,\n    pub angletolerance: f64,\n    pub algo: String,\n    pub pointer: Value,\n    pub cachesolve: bool,\n    pub recursionlevel: i64,\n    pub values: Vec&lt;Value&gt;,\n    pub warnings: Vec&lt;Value&gt;,\n    pub errors: Vec&lt;Value&gt;,\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Json 内で null だったり空の配列だったりする箇所は当然自動で生成されないのでここは Schema を見ながら修正してきましょう。\n修正した結果が以下になります。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct Schema {\n    pub absolutetolerance: f64,\n    pub angletolerance: f64,\n    pub algo: Option&lt;String&gt;,\n    pub pointer: Option&lt;String&gt;,\n    pub cachesolve: bool,\n    pub recursionlevel: i64,\n    pub values: Vec&lt;DataTree&gt;,\n    pub warnings: Vec&lt;String&gt;,\n    pub errors: Vec&lt;String&gt;,\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct DataTree {\n    #[serde(rename = &quot;ParamName&quot;)]\n    pub param_name: String,\n    #[serde(rename = &quot;InnerTree&quot;)]\n    pub inner_tree: HashMap&lt;String, Vec&lt;RestHopperObject&gt;&gt;,\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct RestHopperObject {\n    #[serde(rename = &quot;type&quot;)]\n    pub object_type: String,\n    pub data: String,\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">algo</code> と <code class=\"language-text\">pointer</code> は null（Rust では None）になる可能性があるので Option の Enum を使用して None または Some(T) を扱えるようにしています。</p>\n<p><code class=\"language-text\">warnings</code> と <code class=\"language-text\">errors</code> は文字列の配列である <code class=\"language-text\">Vec&lt;String></code> としています。</p>\n<p><code class=\"language-text\">values</code> は Grasshopper のツリーの情報を入れるため、別途 <code class=\"language-text\">DataTree</code> という構造体を作成しています。\nC# の Schema ファイルでは、DataTree は別の扱い方をしていますが、簡単に扱うためここでは違う構成にしています。\nDataTree はパラメータの名前である <code class=\"language-text\">param_name</code> とそのパラメータに入れる値のパスの String と実際の値を持つ <code class=\"language-text\">inner_tree</code> の HashMap で構成しています。</p>\n<p>同様にして Response の構造体も作成します。\n作成した内容は以下です。\nこちらの内容は C# の Schema.cs と同様の内容を Rust の構造体に書き換えたものとなっています。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct IoResponseSchema {\n    #[serde(rename = &quot;Description&quot;)]\n    pub description: Option&lt;String&gt;,\n    #[serde(rename = &quot;CacheKey&quot;)]\n    pub cache_key: Option&lt;String&gt;,\n    #[serde(rename = &quot;InputNames&quot;)]\n    pub input_names: Vec&lt;String&gt;,\n    #[serde(rename = &quot;OutputNames&quot;)]\n    pub output_names: Vec&lt;String&gt;,\n    #[serde(rename = &quot;Icon&quot;)]\n    pub icon: Option&lt;String&gt;,\n    #[serde(rename = &quot;Inputs&quot;)]\n    pub inputs: Vec&lt;InputParamSchema&gt;,\n    #[serde(rename = &quot;Outputs&quot;)]\n    pub outputs: Vec&lt;IoParamSchema&gt;,\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct InputParamSchema {\n    #[serde(rename = &quot;Description&quot;)]\n    pub description: String,\n    #[serde(rename = &quot;AtLeast&quot;)]\n    pub at_least: f64,\n    #[serde(rename = &quot;AtMost&quot;)]\n    pub at_most: f64,\n    #[serde(rename = &quot;Default&quot;)]\n    pub default: String,\n    #[serde(rename = &quot;Minimum&quot;)]\n    pub minimum: Value,\n    #[serde(rename = &quot;Maximum&quot;)]\n    pub maximum: Value,\n    #[serde(rename = &quot;Name&quot;)]\n    pub name: String,\n    #[serde(rename = &quot;Nickname&quot;)]\n    pub nickname: Option&lt;String&gt;,\n    #[serde(rename = &quot;ParamType&quot;)]\n    pub param_type: String,\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = &quot;camelCase&quot;)]\npub struct IoParamSchema {\n    #[serde(rename = &quot;Name&quot;)]\n    pub name: Option&lt;String&gt;,\n    #[serde(rename = &quot;Nickname&quot;)]\n    pub nickname: Option&lt;String&gt;,\n    #[serde(rename = &quot;ParamType&quot;)]\n    pub param_type: Option&lt;String&gt;,\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>通信部分の作成</h3>\n<p>IO 用の構造体が作成できたので、次にそれらを Post する部分を作成していきます。\n必要な依存関係として、通信用にバイナリ（gh のファイル）を Base64 に変換する base64 と通信のための reqwest と非同期化に必要な tokio を依存関係に追加します。</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-toml line-numbers\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">dependencies</span><span class=\"token punctuation\">]</span>\n<span class=\"token key property\">base64</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"0.13.0\"</span>\n<span class=\"token key property\">reqwest</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token key property\">version</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"0.11\"</span><span class=\"token punctuation\">,</span> <span class=\"token key property\">features</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"json\"</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n<span class=\"token key property\">serde</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1.0.136\"</span>\n<span class=\"token key property\">serde_derive</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1.0.136\"</span>\n<span class=\"token key property\">serde_json</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1.0.78\"</span>\n<span class=\"token key property\">tokio</span> <span class=\"token punctuation\">=</span>  <span class=\"token punctuation\">{</span> <span class=\"token key property\">version</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token key property\">features</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"full\"</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>はじめに Grasshopper のファイルを /io にポストする部分を作成します。\n実装としては引数に &#x26;str で gh ファイルへのパスをとり、ポストした結果を Result で返すようにしています。\nまた通信なので関数は非同期とするためはじめに <code class=\"language-text\">async</code> をつけています。</p>\n<p>/io へのポストなので、algo に gh ファイルのデータが入ったものをいれ、レスポンスでそのデータへの cache_key が返ってくることを期待しています。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">use base64::encode;\nuse std::fs::File;\nuse std::io::Read;\n\nuse crate::{io, URL};\n\nasync fn upload_definition(\n    gh_path: &amp;str,\n) -&gt; Result&lt;io::IoResponseSchema, Box&lt;dyn std::error::Error&gt;&gt; {\n    // io の URL を作成\n    let io_url = URL.to_owned() + &quot;io&quot;;\n\n    // ファイルを読み込み、Base64 にエンコード\n    let mut gh_file = File::open(gh_path).unwrap();\n    let mut buf = Vec::new();\n    let _ = gh_file.read_to_end(&amp;mut buf);\n    let encoded: &amp;str = &amp;encode(&amp;buf);\n\n    // body となる各値を作成し Json の文字列化\n    let io_schema = io::Schema {\n        absolutetolerance: 0.0,\n        angletolerance: 0.0,\n        algo: Some(encoded.to_owned()),\n        pointer: None,\n        cachesolve: false,\n        recursionlevel: 0,\n        values: Vec::new(),\n        warnings: Vec::new(),\n        errors: Vec::new(),\n    };\n    let io_body = serde_json::to_string(&amp;io_schema)?;\n\n    // ポストして結果の Json をデシリアライズ\n    let client = reqwest::Client::new();\n    let res = client\n        .post(io_url)\n        .body(io_body)\n        .send()\n        .await?\n        .json::&lt;io::IoResponseSchema&gt;()\n        .await?;\n\n    Ok(res)\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Rust はコンパイラが細かいと聞いたことがある方もいると思いますので、その例をここで示します。\n上で io_schema を作成している箇所で、absolutetolerance は f64 なのですが、文字列 \"0.0\" をいれて <code class=\"language-text\">cargo check</code> を実行します。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">let io_schema = io::Schema {\n    absolutetolerance: &quot;0.0&quot;,</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>このようにどこがどのようにダメなのかを細かくコンパイラが教えてくれます。\n基本的にはこのコンパイラの指示に素直に従っていればコードが仕上がっていきます。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">error[E0308]: mismatched types\n  --&gt; src\\grasshopper.rs:15:28\n   |\n15 |         absolutetolerance: &quot;0.0&quot;,\n   |                            ^^^^^ expected `f64`, found `&amp;str`</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>/io からのレスポンスでポストした gh ファイルの cache key が返ってくるので、それを使って実際にファイルを評価する部分を作成します。</p>\n<p>実装としては mcneel の Python の compute-rhino3d の実装に倣って、gh ファイルのパスと DataTree を受け取ってそれを使って処理する関数としています。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">pub async fn evaluate_definition(\n    gh_path: &amp;str,\n    data_tree: Vec&lt;io::DataTree&gt;,\n) -&gt; Result&lt;io::Schema, Box&lt;dyn std::error::Error&gt;&gt; {\n\n    // 上で実装した /io へのポストを使って cache_key を取得\n    let cache_key = upload_definition(gh_path).await?.cache_key;\n\n    // io の URL を作成\n    let solve_url = URL.to_owned() + &quot;grasshopper&quot;;\n\n    // body となる各値を作成し Json の文字列化\n    let solve_schema = io::Schema {\n        absolutetolerance: 0.001,\n        angletolerance: 1.0,\n        cachesolve: false,\n        algo: None,\n        pointer: cache_key,\n        recursionlevel: 0,\n        values: data_tree,\n        warnings: Vec::new(),\n        errors: Vec::new(),\n    };\n    let solve_body = serde_json::to_string(&amp;solve_schema)?;\n\n    // ポストして結果の Json をデシリアライズ\n    let solve_client = reqwest::Client::new();\n    let solve_res = solve_client\n        .post(solve_url)\n        .body(solve_body)\n        .send()\n        .await?\n        .json::&lt;io::Schema&gt;()\n        .await?;\n\n    Ok(solve_res)\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>これで Grasshopper ファイルを実行して値を取得する部分の作成が完了しました。</p>\n<h3>main.rs の作成</h3>\n<p>IO の部分、通信する部分が作成できたので、これらをまとめて実際にポストするデータを作成し結果を表示する部分を作成していきます。</p>\n<div class=\"gatsby-highlight\" data-language=\"rs\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-rs line-numbers\"><code class=\"language-rs\">mod grasshopper;\nmod io;\n\nuse std::collections::HashMap;\n\n// ベースとなる URL 作成\nconst URL: &amp;str = &quot;http://localhost:6500/&quot;;\n\n// 非同期のメイン関数であることを示すため #[tokio::main] を付ける\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n\n    // grasshopper のパスを入れる\n    let gh_path = &quot;definitions/sum.gh&quot;;\n\n    // インプット用の DataTree を作成する\n    let mut input_tree: Vec&lt;io::DataTree&gt; = Vec::new();\n    let mut tree = HashMap::new();\n    tree.insert(\n        &quot;0&quot;.to_string(),\n        vec![io::RestHopperObject {\n            object_type: &quot;System.Double&quot;.to_string(),\n            data: &quot;1.0&quot;.to_string(),\n        }],\n    );\n    input_tree.push(io::DataTree {\n        param_name: &quot;A&quot;.to_string(),\n        inner_tree: tree,\n    });\n\n    let mut tree = HashMap::new();\n    tree.insert(\n        &quot;0&quot;.to_string(),\n        vec![io::RestHopperObject {\n            object_type: &quot;System.Double&quot;.to_string(),\n            data: &quot;2.0&quot;.to_string(),\n        }],\n    );\n    input_tree.push(io::DataTree {\n        param_name: &quot;B&quot;.to_string(),\n        inner_tree: tree,\n    });\n\n    // RhinoCompute と通信して結果を受け取る\n    let output = grasshopper::evaluate_definition(gh_path, input_tree).await?;\n\n    // 各結果を表示する\n    // エラーの結果\n    let errors = output.errors;\n    if !errors.is_empty() {\n        println!(&quot;Errors:&quot;);\n        for error in errors {\n            println!(&quot;{}&quot;, error);\n        }\n    }\n\n    // ワーニングの結果\n    let warnings = output.warnings;\n    if !warnings.is_empty() {\n        println!(&quot;Warnings:&quot;);\n        for warning in warnings {\n            println!(&quot;{}&quot;, warning);\n        }\n    }\n\n    // RH_OUT で得られた結果\n    let values = output.values;\n    for value in values {\n        let name = value.param_name;\n        let inner_tree = value.inner_tree;\n        println!(&quot;{}&quot;, name);\n        for (key, value) in inner_tree {\n            println!(&quot;{}&quot;, key);\n            for v in value {\n                println!(&quot;{}&quot;, v.data);\n            }\n        }\n    }\n\n    Ok(())\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>すべてできたら <code class=\"language-text\">cargo check</code> を実行して問題がないか確認しましょう。\n問題なければ RhinoCompute を起動して <code class=\"language-text\">cargo run</code>　することで実際にコードを実行しちゃんと結果が返ってくることを確認しましょう。</p>\n<p>ここでは冒頭で出した A+B の足し算するデータに対して実行しているので結果は 3 が返ってきます。</p>\n<h2>まとめ</h2>\n<p>Rust で RhinoCompute を実行する例を出しましたがどうでしたでしょうか。\nC# や Python とはだいぶ違う言語なため手こずったと思いますが、実際に書きながらすすめると Rust の強力なコンパイラの力を感じられたのではないでしょうか。</p>\n<p>建築系ではあまり使うことはないと思いますが、機会があったら Rust にもぜひチャレンジしてみてください。</p>","excerpt":"はじめに 最近流行りの言語として Rust があり、触ってみたいと思っている方も多いのではないでしょうか。\nただ、建築系ソフトをみるとその多くが Python や C# で SDK が提供されており、仕事で使わない Rust のような言語に触れることはほぼありません。 ならば Rust…","frontmatter":{"date":"12 February, 2022","path":"/articles/deep-dive-into-rhinocompute-through-rust","title":"Deep dive into RhinoCompute through Rust","article_tags":["Rust","RhinoCompute","Grasshopper"]},"fields":{"readingTime":{"text":"6 min read"},"slug":"/deep-dive-into-rhinocompute-through-rust/","collection":"article"}},"site":{"siteMetadata":{"title":"構造とデジタル_最新版_Final(1)"}}},"pageContext":{}},"staticQueryHashes":["32046230","3649515864"]}